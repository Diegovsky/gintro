const std = @import("std");
const C = @cImport(
    @cInclude("girepository.h")
);

pub const RepositoryLoadFlags = enum(c_int) {
    LoadLazy = C.G_IREPOSITORY_LOAD_FLAG_LAZY,
    _,
};

pub const String = struct {
    raw: [*:0]const C.gchar,
    should_free: bool = true,

    const Self = @This();

    pub fn format(value: Self, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        try std.fmt.formatText(value.slice(), fmt, options, writer);
    }

    pub fn new_borrowed(str: [*:0]const u8) Self {
        return .{
            .raw = str,
            .should_free = false,
        };
    }

    pub fn new_copied(str: [*:0]const u8) Self {
        return .{
            .raw = C.g_strdup(str),
        };
    }

    pub fn copy(self: Self) Self {
        return Self.new_copied(self.raw);
    }

    pub fn slice(self: Self) []const u8 {
        return self.raw[0..std.mem.len(self.raw)];
    }

    pub fn deinit(self: Self) void {
        if (self.should_free) {
            C.g_free(self.raw);
        }
    }
    const cstr_align = @alignOf([*c]C.gchar);
    pub fn fromC(raw: [*c]const C.gchar) Self {
        if(raw == null) {
            return .{.raw = "", .should_free=false};
        }
        return .{ .raw = @ptrCast([*:0]const C.gchar, raw) };
    }
};

pub const VString = struct {
    raw: [*:0]const [*:0]const C.gchar,
    should_free: bool = true,

    const Self = @This();

    pub fn deinit(self: Self) void {
        if (self.should_free) {
            C.g_strfreev(self.raw);
        }
    }
    /// The returned string should not be `deinit`ed.
    pub fn get(self: *Self, id: usize) String {
        return .{ .raw = self.raw[id] };
    }

    pub fn fromC(raw: [*c]const [*c]const C.gchar) Self {
        return .{ .raw = @alignCast(@alignOf([*:0][*:0]C.gchar), raw) };
    }
};

/// Currently, acquiring a typelib from a repository is the only supported way.
pub const TypeLib = struct {
    raw: *C.GITypelib,
};

/// This handles every error directly caused by the GObject Introspection library.
pub const RepositoryError = error{
    TypeLibNotFound,
    NamespaceMismatch,
    NamespaceVersionConflict,
    LibraryNotFound,
    UnknownError,
};

/// A generic iterator type used to iterate over Introspection's types that follow this pattern:
/// # Context must have:
///  fn free(Get) void;
///  fn get(usize) ?Get;
///
///  As of now, I'm not sure what this type absolutely needs, to it may change.
///  Also, I'm not sure I like this paradigm I made, so if you have a better idea, DO make a pull request.
pub fn Iterator(comptime Get: type, comptime Context: anytype) type {
    return struct {
        const Self = @This();

        i: usize,
        context: Context,

        pub fn next(self: *Self) ?Get {
            defer self.i += 1;
            return self.context.get(self.i);
        }
    };
}

// Auto Generated by `gen.py`
/// Enum that encodes all of Introspection's types.
pub const TypeInfo = enum(c_int) {
    Invalid = C.GI_INFO_TYPE_INVALID,
    Function = C.GI_INFO_TYPE_FUNCTION,
    Callback = C.GI_INFO_TYPE_CALLBACK,
    Struct = C.GI_INFO_TYPE_STRUCT,
    Boxed = C.GI_INFO_TYPE_BOXED,
    Enum = C.GI_INFO_TYPE_ENUM,
    Flags = C.GI_INFO_TYPE_FLAGS,
    Object = C.GI_INFO_TYPE_OBJECT,
    Interface = C.GI_INFO_TYPE_INTERFACE,
    Constant = C.GI_INFO_TYPE_CONSTANT,
    Union = C.GI_INFO_TYPE_UNION,
    Value = C.GI_INFO_TYPE_VALUE,
    Signal = C.GI_INFO_TYPE_SIGNAL,
    Vfunc = C.GI_INFO_TYPE_VFUNC,
    Property = C.GI_INFO_TYPE_PROPERTY,
    Field = C.GI_INFO_TYPE_FIELD,
    Arg = C.GI_INFO_TYPE_ARG,
    Type = C.GI_INFO_TYPE_TYPE,
    Unresolved = C.GI_INFO_TYPE_UNRESOLVED,

    pub fn fromC(en: c_uint) @This() {
        return @intToEnum(TypeInfo, en);
    }
};

pub const BaseInfo = struct {
    raw: *C.GIBaseInfo,

    const Self = @This();
    pub fn ref(self: *Self) Self {
        return .{ .raw = C.g_base_info_ref(self.raw).? };
    }
    /// Call this when you're done with this `BaseInfo`.
    pub fn unref(self: Self) void {
        C.g_base_info_unref(self.raw);
    }
    /// Get the introspection type.
    pub fn getType(self: *const Self) TypeInfo {
        var value = C.g_base_info_get_type(self.raw);
        return TypeInfo.fromC(value);
    }
    pub fn getName(self: *const Self) ?String {
        const res = C.g_base_info_get_name(self.raw);
        if (res) |name| {
            return String.fromC(name);
        }
        return null;
    }
    const BaseInfoAttributesIterator = struct {
        raw: C.GIAttributeIter,
        ref: BaseInfo,
        i: i32 = 0,

        pub fn new(ref_: BaseInfo) @This() {
            return .{
                .raw = std.mem.zeroes(C.GIAttributeIter),
                .ref = ref_,
            };
        }

        pub fn next(self: *@This()) ?[2]String {
            var name: [*c]C.gchar = undefined;
            var val: [*c]C.gchar = undefined;
            if (C.g_base_info_iterate_attributes(self.ref.raw, &self.raw, &name, &val) == 1) {
                const nstr = String.fromC(name);
                const vstr = String.fromC(val);
                return .{ nstr, vstr };
            } else {
                std.debug.print("Iterations: {any}\n", .{ self.i });
                return null;
            }
        }
    };
    pub fn getIterator(self: Self) BaseInfoAttributesIterator {
        return BaseInfoAttributesIterator.new(self);
    }
    pub fn fromC(raw: [*c]C.GIBaseInfo) Self {
        return .{ .raw = @alignCast(@alignOf(*BaseInfo), raw) };
    }
};

/// Gnome docs says different repos might never be supported, but we make the assumption that it's a possibility.
pub const Repository = struct {
    raw: *C.GIRepository,
    last_error: ?*C.GError,

    const Self = @This();

    /// Returns the default Repository of this process.
    pub fn default() Self {
        return .{
            .last_error = null,
            .raw = C.g_irepository_get_default(),
        };
    }
    /// Be aware the flag argument *will probably change* due to the API only specifying ONE flag.
    /// If this returns an UnknownError, it happened in GLib. In that case, more information is avaliable at Repository.last_error.
    pub fn require(self: *Self, namespace: *Namespace, flag: RepositoryLoadFlags) RepositoryError!TypeLib {
        var raw = C.g_irepository_require(self.raw, namespace.name, namespace.version, @intCast(c_uint, @enumToInt(flag)), &self.last_error);
        if (raw) |ptr| {
            return TypeLib{ .raw = ptr };
        } else if (self.last_error) |err| {
            return switch (err.code) {
                C.G_IREPOSITORY_ERROR_TYPELIB_NOT_FOUND => error.TypeLibNotFound,
                C.G_IREPOSITORY_ERROR_NAMESPACE_MISMATCH => error.NamespaceMismatch,
                C.G_IREPOSITORY_ERROR_NAMESPACE_VERSION_CONFLICT => error.NamespaceVersionConflict,
                C.G_IREPOSITORY_ERROR_LIBRARY_NOT_FOUND => error.LibraryNotFound,
                else => error.UnknownError,
            };
        } else {
            unreachable;
        }
    }
    /// You should free the resulting array with `VString.deinit`.
    pub fn getDependencies(self: *Self, namespace: *Namespace) ?VString {
        var raw = C.g_irepository_get_dependencies(self.raw, namespace.name) orelse return null;
        return .{ .raw = raw };
    }
    /// See [getDependencies] for more info.
    pub fn getImmediateDependencies(self: *Self, namespace: *Namespace) ?VString {
        var raw = C.g_irepository_get_immediate_dependencies(self.raw, namespace.name) orelse return null;
        return .{ .raw = raw };
    }

    const InfoIteratorContext = struct {
        namespace: *Namespace,
        repo: *C.GIRepository,

        const Get = BaseInfo;

        pub fn get(self: *@This(), ii: usize) ?Get {
            var len = @intCast(usize, C.g_irepository_get_n_infos(self.repo, self.namespace.name));
            if (ii >= len) {
                return null;
            }
            return BaseInfo.fromC(C.g_irepository_get_info(self.repo, self.namespace.name, @intCast(i32, ii)));
        }
    };
    const InfoIterator = Iterator(BaseInfo, InfoIteratorContext);

    pub fn getInfoIterator(self: *Self, namespace: *Namespace) InfoIterator {
        return .{ .i = 0, .context = .{ .namespace = namespace, .repo = self.raw } };
    }
};

pub const Namespace = struct {
    name: [*c]const u8,
    version: [*c]const u8,
};
